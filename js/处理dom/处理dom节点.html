<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /***【插入1】***/
      console.log('------向div中插入span------')
      //创建一个div节点, 一个span节点
      const div1 = document.createElement('div')
      const span1 = document.createElement('span')
      //给span节点添加 dataset
      span1.dataset.regionId = '123';
      //将span节点【插入】到div节点中
      div1.appendChild(span1)
      console.log(div1)

      /***【移除】***/
      console.log('-------将div中的span移出------')
      //创建一个div节点, 一个span节点
      const div2 = document.createElement('div')
      const span2 = document.createElement('span')
      //将span节点插入到div节点中
      div2.appendChild(span2)
      //将span节点【移除】
      div2.removeChild(span2)
      console.log(div2)

      /***【插入2】***/
      console.log('-------向frag中插入span，再将frag插入到div------')
      const div11 = document.createElement('div')
      // 创建一个frag， 往frag里面插入节点，再将frag插入到div中
      let frag = document.createDocumentFragment()
      const span11 = document.createElement('span')
      const span22 = document.createElement('span')
      const span33 = document.createElement('span')
      frag.appendChild(span11)
      frag.appendChild(span22)
      frag.appendChild(span33)

      div11.appendChild(frag)
      console.log(div11)

      /***【子节点的替换】返回值是被替换对象节点***/
      console.log('-------将div中的子节点span替换成p------')
      //创建一个div节点, 一个span节点
      const div3 = document.createElement('div')
      let frag2 = document.createDocumentFragment()
      const span111 = document.createElement('span')
      const span222 = document.createElement('span')
      const span333 = document.createElement('span')
      frag2.appendChild(span111)
      frag2.appendChild(span222)
      frag2.appendChild(span333)
      div3.appendChild(frag2)
      console.log(div3)

      const p = document.createElement('p')
      p.textContent = '被替换进来的p节点'
      div3.replaceChild(p, span333)

      /***【子节点的插入】返回值是插入的节点***/
      console.log('-------向div中插入新节点p------')
      //创建一个div节点, 一个span节点
      const div4 = document.createElement('div')
      let frag3 = document.createDocumentFragment()
      const span1111 = document.createElement('span')
      span1111.id = 'sp1'
      const span2222 = document.createElement('span')
      span2222.id = 'sp2'
      const span3333 = document.createElement('span')
      span3333.id = 'sp3'
      frag3.appendChild(span1111)
      frag3.appendChild(span2222)
      frag3.appendChild(span3333)
      div4.appendChild(frag3)
      div4.id = 'div4————id'
      console.log(div4)

      const p2 = document.createElement('p')
      p2.textContent = '插入的节点'
      // 将p2查到div4里，插入的位置是div4的第一个子元素前。
      div4.insertBefore(p2, div4.firstChild) 
      // 将p2查到div4里，插入的位置是div4的第一个子元素前。
      div4.insertBefore(p2, div4.firstChild) 
      // p2是需要插入的节点  将p2插入到div4.firstChild.nextSibling(div4的第二个节点)【之前】的位置， 也就是 div4.firstChild(div4的第一个节点)【之后】的位置
      div4.insertBefore(p2, div4.firstChild.nextSibling) 
      
      // 把p2和div4元素替换
      // div4.parentNode.replaceChild(p2, div4);
      // @todo 对比一下和下面这个有区别吗
      // div4 = p2

      console.log('--p2的父节点--')
      console.log(p2.parentNode) // 查找节点的父节点
      console.log('--p2的父节点的id属性的值--')
      console.log(p2.parentNode.attributes['id'].textContent)
      console.log(p2.parentNode.getAttribute('id'))
      console.log('--p2的父节点的标签值- *tagName属性返回的字符串始终以大写字母表示-')
      console.log(p2.parentNode.tagName);
      console.log('--p2的上一个兄弟点--')
      console.log(p2.previousSibling) // 查找节点的父节点
      console.log('--p2的下一个兄弟点--')
      console.log(p2.nextSibling) // 查找节点的父节点
      console.log('--div4的子节点--')
      console.log(div4.childNodes) // 查找节点的子节点
      console.log('--div4的子节点 nodeType- : 1元素节点  3文本节点-');
      div4.childNodes.forEach(node => {
        console.log(node, node.nodeType);  // nodeType : 1元素节点  3文本节点
      })

      /***创建节点，编辑样式***/
      console.log('-------创建节点，编辑样式------')
      const imgBox = document.createElement('div')
      const spanQ = document.createElement('span')
      imgBox.appendChild(spanQ)
      imgBox.style.backgroundColor = 'red'
      imgBox.style.padding = '20px'
      console.log(imgBox)

      /***节点的深浅 克隆***/
      console.log('-------节点的深浅 克隆------')
      const Deep_clone_div4 = div4.cloneNode(true)
      console.log(Deep_clone_div4)
      const clone_div4 = div4.cloneNode(false)
      console.log(clone_div4)

      /***dom节点如何变成range类型***/
      // /// 获取DOM节点
      // const node = document.getElementById('myNode');
      // // 创建Range对象
      // const range = document.createRange();
      // // 设置Range的起始和结束位置
      // range.setStart(node, 0);
      // range.setEnd(node, node.childNodes.length);
      // // 现在可以使用这个Range对象来操作DOM节点了

      /***获取img元素的兄弟节点***/
      // const brothers = [...$div.children].filter(item => !(item as HTMLElement).innerHTML.includes('img'))

      // 判断是img节点
      // node.tagName === 'IMG'

      /***获取全部的文本节点(nodeType === 3)***/
      // const getTextNodes = (node)=>{
      //   let textNodes = [];
      //   for (let i = 0; i < node.childNodes.length; i++) {
      //       let childNode = node.childNodes[i];
      //       if (childNode.nodeType === 3) { // Node.TEXT_NODE === 3
      //           textNodes.push(childNode);
      //       } else if (childNode.childNodes) { // 如果子节点存在，递归处理
      //           textNodes = textNodes.concat(getTextNodes(childNode));
      //       }
      //   }
      //   return textNodes;
      // }
      // let textNodes = getTextNodes(brothers[0]);
      // console.log(textNodes);

      /***
       * 一个DOM节点到顶点的距离可以通过使用DOM元素的offsetTop属性来获取。
       * offsetTop表示该元素到其父元素顶部的距离。
       * 如果没有父元素具有定位属性，那么offsetTop属性将进行迭代计算，直到找到body元素。
       * ***/

       /**
        * 获取node元素的行高
        * window.getComputedStyle(node).getPropertyValue('font-size')
        * parseFloat(window.getComputedStyle(node).getPropertyValue('font-size'))
       */

       /*  选中dom
       *    const selection = window.getSelection();
       *    const range = selection.getRangeAt(0);
       */

       /** 
        *  滚动条滚到底 (展示最新一条数据)
        * (this.$refs.theBody as HTMLElement).scrollTop = (this.$refs.theBody as HTMLElement).scrollHeight;
        * document.getElementById('page-container').scrollTop = document.getElementById('page-container').scrollHeight;
       */

       // 获取第一个【元素】子节点
      function getFirstElementChild(node) {
        return node.firstElementChild || node.children[0]; // 兼容旧版IE浏览器，它们可能不支持firstElementChild
      }
      
      // 获取最后一个【元素】子节点
      function getLastElementChild(node) {
        let lastChild = node.lastElementChild; // 尝试获取最后一个元素子节点
        if (!lastChild && node.children.length > 0) {
          // 如果lastElementChild不存在（可能是在旧版IE中），则使用children集合
          lastChild = node.children[node.children.length - 1];
        }
        return lastChild;
      }

      // 判断当前 img 标签是否是 p祖先标签 的最后一个节点 所包含的
      findParentWithTag(img, 'P').lastChild.querySelector('img')?.src === img.src

      
      // 使用 DOMParser 解析字符串为 DOM 元素
      const htmlString = '<p><img width="112" data-tif-src="https://book-stable.oss-cn-shanghai.aliyuncs.com/img/668280e9034ffe000a60b5f6/4ca0003.tif" data-filename="4ca0003.tif" data-image-uid="03cc03c74" height="52.5" is_formula="True" ref_font_size="10.5pt" src="http://book-stable.oss-cn-shanghai.aliyuncs.com/img/668280e9034ffe000a60b5f6/4ca0003.jpg?x-oss-process=image&t=1735296383938" style="vertical-align:middle; -aw-left-pos:0pt; -aw-rel-hpos:column; -aw-rel-vpos:paragraph; -aw-top-pos:0pt; -aw-wrap-type:inline" uid="y6faifWOH">倒车雷达利用超声波传递信息</p>'
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, 'text/html');
      console.log(doc);

      // 获取一个dom所有叶子节点 (只找第一层)
      function getLeafNodes(node) {
        let leafNodes = [];
        function traverse(n) {
            // 如果节点是元素节点并且没有子元素，或者节点是文本节点（非空），则它是叶子节点
            if ((n.nodeType === Node.ELEMENT_NODE && n.childElementCount === 0) || (n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() !== '')) {
                leafNodes.push(n);
            } else if (n.nodeType === Node.ELEMENT_NODE && n.childElementCount > 0) {
                // 如果节点是元素节点并且有子元素，则递归遍历其子元素
                Array.from(n.children).forEach(child => traverse(child));
            }
        }
        traverse(node);
        return leafNodes;
      }
      // 获取一个dom所有叶子节点 (获取全部层级中所有最底层的叶子节点)  ???? 
      function traverseAndCollectLeafNodes(node, leafNodes = []) {
        // 检查当前节点是否为叶子节点
        const isLeaf = (n) => {
          // 元素节点如果没有子元素节点，则视为叶子节点
          // 文本节点（包括空白文本）也视为叶子节点
          return (
            (n.nodeType === Node.ELEMENT_NODE && n.childElementCount === 0) ||
            (n.nodeType === Node.TEXT_NODE && n.nodeValue !== null)
          );
        };

        // 如果是叶子节点，则添加到结果数组中
        if (isLeaf(node)) {
          leafNodes.push(node);
        } else {
          // 如果不是叶子节点，则递归遍历其子节点
          Array.from(node.childNodes).forEach((childNode) => {
            traverseAndCollectLeafNodes(childNode, leafNodes);
          });
        }

        leafNodes = leafNodes.filter((node) => {
          if (node && node.nodeType === Node.TEXT_NODE) return node.textContent.trim();
          else return node;
        });
        return leafNodes;
      }


      ///  离屏容器 可用来计算不需要显示在文档流中的dom的高度
      let offScreenContainer = document.createElement('div');
      // 设置样式以确保它不会在页面上可见
      offScreenContainer.style.position = 'absolute';
      offScreenContainer.style.left = '-9999px';
      offScreenContainer.style.top = '-9999px';
      // 你可以选择将 offScreenContainer 添加到 body 或其他合适的容器中
      document.body.appendChild(offScreenContainer);
      // 创建并设置你想要计算宽度的元素
      let div = document.createElement('div');
      div.innerHTML = `
        <div class="option">
          <span data-prop="letter" class="m-r-5">A.</span>
          <span><p>时间</p></span>
        </div>
        <div class="option">
          <span data-prop="letter" class="m-r-5">B.</span>
          <span><p>温度</p></span>
        </div>
        <div class="option">
          <span data-prop="letter" class="m-r-5">C.</span>
          <span><p>长度</p></span>
        </div>
        <div class="option">
          <span data-prop="letter" class="m-r-5">D.</span>
          <span><p>质量</p></span>
        </div>
      `;
      // 将元素添加到离屏容器中
      offScreenContainer.appendChild(div);
      let width = div.offsetWidth; // 或者使用 div.getBoundingClientRect().width
      console.log('Calculated width:', width);
      // 最后，从 DOM 中移除离屏容器（如果你不再需要它）
      document.body.removeChild(offScreenContainer);




      // 
    </script>
  </body>
</html>
